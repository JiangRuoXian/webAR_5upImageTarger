<!doctype html>
<html lang="zh-Hant">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>MindAR — Clean 5 Targets + Progress (Bigger Model)</title>

    <!-- Three.js（與 v1.1.5 相容的 r137） -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.5/build/three.min.js"></script>
    <!-- MindAR 非模組版 -->
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.1.5/dist/mindar-image-three.prod.js"></script>

    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #000;
            overflow: hidden;
        }

        #app {
            position: fixed;
            inset: 0;
        }

        #start {
            position: fixed;
            inset: 0;
            margin: auto;
            width: 180px;
            height: 48px;
            border-radius: 10px;
            border: 0;
            font-size: 16px;
            cursor: pointer;
            background: #222;
            color: #fff;
        }

        /* Loading Overlay */
        #loading {
            position: fixed;
            inset: 0;
            display: none;
            place-items: center;
            z-index: 5;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, .7) 0%, rgba(0, 0, 0, .9) 100%);
        }

        #loading .box {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: #fff;
        }

        .spinner {
            width: 56px;
            height: 56px;
            border: 6px solid rgba(255, 255, 255, 0.25);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #progressText {
            font: 14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            letter-spacing: .5px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div id="app"></div>
    <button id="start">Start AR</button>

    <!-- Loading overlay with spinner + percentage -->
    <div id="loading">
        <div class="box">
            <div class="spinner"></div>
            <div id="progressText">0%</div>
        </div>
    </div>

    <script>
        // ===== 參數（偵測設定不變） =====
        const TARGETS_PATH = './targets.mind';   // 與本檔同資料夾
        const MAX_TRACK = 5;                     // 同時追蹤 5 張
        const COLORS = [0xff5555, 0x55ff55, 0x5599ff, 0xffcc33, 0xcc66ff]; // 五顆球顏色

        // ★ 模型大小（球半徑，單位：公尺）。需要更大/更小改這裡即可。
        const BALL_RADIUS = 0.14;                // 原本 0.05 → 現在放大到 0.14
        const BALL_HEIGHT = BALL_RADIUS + 0.005; // 離平面一點，避免 Z-fighting

        // ===== 內部變數 =====
        let mindarThree, renderer, scene, camera;
        let started = false;
        const startBtn = document.getElementById('start');
        const loadingEl = document.getElementById('loading');
        const progressEl = document.getElementById('progressText');

        // 下載檔案並回報進度
        async function fetchWithProgress(url, onProgress) {
            const res = await fetch(url, { method: 'GET' });
            if (!res.ok) throw new Error('HTTP ' + res.status);

            const total = Number(res.headers.get('Content-Length')) || 0;
            const reader = res.body && res.body.getReader ? res.body.getReader() : null;

            if (!reader) {
                const blob = await res.blob();
                onProgress && onProgress(100);
                return blob;
            }

            let received = 0;
            const chunks = [];
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                received += value.length;
                if (total) onProgress && onProgress(Math.max(1, Math.min(99, Math.floor(received / total * 100))));
            }
            const blob = new Blob(chunks, { type: res.headers.get('Content-Type') || 'application/octet-stream' });
            onProgress && onProgress(100);
            return blob;
        }

        async function startAR() {
            if (started) return;
            started = true;
            startBtn.style.display = 'none';
            loadingEl.style.display = 'grid';
            progressEl.textContent = '0%';

            try {
                // 1) 下載 targets.mind（可視化%數）
                const mindBlob = await fetchWithProgress(TARGETS_PATH, p => { progressEl.textContent = p + '%'; });

                // 2) 以 Blob URL 建立 MindAR（避免重複下載）
                const mindURL = URL.createObjectURL(mindBlob);

                mindarThree = new window.MINDAR.IMAGE.MindARThree({
                    container: document.querySelector('#app'),
                    imageTargetSrc: mindURL,
                    maxTrack: MAX_TRACK,
                });
                ({ renderer, scene, camera } = mindarThree);

                // 3) 場景與 5 個 anchors（每張圖一顆更大的球）
                scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
                for (let i = 0; i < MAX_TRACK; i++) {
                    const anchor = mindarThree.addAnchor(i);
                    const group = new THREE.Group();
                    const mesh = new THREE.Mesh(
                        new THREE.SphereGeometry(BALL_RADIUS, 20, 20),
                        new THREE.MeshStandardMaterial({ color: COLORS[i % COLORS.length], metalness: 0.0, roughness: 0.7 })
                    );
                    mesh.position.set(0, BALL_HEIGHT, 0);
                    group.add(mesh);
                    anchor.group.add(group);
                }

                // 4) 啟動追蹤
                progressEl.textContent = '100%';
                await mindarThree.start();
                loadingEl.style.display = 'none';
                renderer.setAnimationLoop(() => renderer.render(scene, camera));

                // 釋放 Blob URL
                setTimeout(() => URL.revokeObjectURL(mindURL), 3000);
            } catch (e) {
                loadingEl.style.display = 'none';
                alert('啟動失敗：' + e);
                started = false;
                startBtn.style.display = 'block';
            }
        }

        startBtn.addEventListener('click', startAR);
    </script>
</body>

</html>